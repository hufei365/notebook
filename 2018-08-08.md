# 不要阻塞事件循环（或工作池）

## 你应该阅读本指南吗？
如果您编写比命令行脚本更复杂的程序，那么阅读本文可以帮助您编写性能更高，更安全的应用程序。

在编写本文档时，主要是基于Node服务器。但里面的原则也适用于其它复杂的Node应用程序。在没有特别说明操作系统的情况下，默认为Linux。

## TL; DR
Node.js在事件循环（初始化和回调）中运行JavaScript代码，并提供工作池来处理成本比较高的任务，如文件I/O。 Node服务节点有很强的扩展能力，有时能提供比相对较重的Apache更好的解决方案。关键点就在于它使用少量线程来处理多客户端连接。如果Node可以使用更少的线程，那么它可以将更多的系统时间和内存用于客户端，而不是为线程（内存，上下文切换）占用额外空间和时间。但也因为Node只有少量的线程，因此在构建应用程序时，必须明智地使用它们。


这里有一些保持Node服务器快速稳健运行的经验法则： 当在任何给定时间与每个客户端关联的工作“很小”时，Node服务会很快。

这适用于事件循环上的回调和工作池上的任务。

## 为什么我要避免阻塞事件循环和工作池？
Node使用少量的线程来处理多个客户端连接。在Node中有两种类型的线程：

- 一个事件循环（又称主循环，主线程，事件线程等）；
- `k`工作池（也称为线程池）中的工作池

如果一个线程需要很长时间来执行回调（Event Loop）或任务（Worker），我们称之为“阻塞”。虽然线程为处理一个客户端连接而阻塞，但它无法处理来自任何其他客户端的请求。这提供了阻止事件循环和工作池的两个动机：

1. **性能**：如果经常在任一类型的线程上执行重量级活动，则服务器的吞吐量（请求/秒）将受到影响；
2. **安全性**：如果某个输入可能会阻塞某个线程，则恶意客户端可能会提交此“恶意输入”，使线程阻塞，从而阻塞其它客户端上的处理。这就很方便地的造成了 **拒绝服务攻击**。


## 快速回顾一下Node
Node使用事件驱动架构：它有一个事件循环用于调度 和 一个处理阻塞任务的工作池。

### 什么代码在事件循环上运行？
在开始时，Node应用程序首先完成初始化阶段，即require模块和注册事件的回调。然后，Node应用程序进入事件循环，通过执行相应的回调来响应传入的客户端请求。此回调同步执行，并在完成后又有可能注册新的异步请求。这些新异步请求的回调也将在事件循环上执行。

事件循环中还包含其它一些非阻塞异步请求（例如，网络I/O）产生的回调。

总之，Event Loop执行这些注册为某些事件的JavaScript回调，并且还负责完成非阻塞异步请求，如网络I/O.


### 什么代码在线程池（Worker Pool）中运行

Node的线程池通过`libuv`([docs](http://docs.libuv.org/en/v1.x/threadpool.html))实现。`libuv`暴露出一组任务提交的API。

Node使用线程池（Worker Pool）处理比较费时的任务。例操作系统没有提供非阻塞版本的I/O, CPU密集型任务等。

会用到线程池的Node模块：

- I/O密集型
    - DNS: `dns.lookup()`, `dns.lookupService()`
    - fs: 除了`fs.FSWatcher()`和所有明确同步调用的文件API，剩下的都会用到libuv实现的线程池
- CPU密集型
    - Crypto: `crypto.pbkdf2()`, `crypto.randomBytes()`, `crypto.randomFill()`
    - Zlib: 除了明确声明使用同步调用的API，剩下的都会用到libuv的线程池


在大多数Node应用程序中，这些API是Worker Pool的唯一任务源。实际上，使用C++插件的应用程序和模块也可以提交任务给工作池。

为了完整起见，我们注意到当从事件循环上的回调中调用上述其中一个API时，事件循环会花费一些较小的设置成本。因为需要进入该API相关的C++实现模块并将任务提交给工作池。与任务的总成本相比，这些成本可以忽略不计，这就是事件循环将它转接到C++模块的原因。将这些任务之一提交给Worker Pool时，Node会在Node C++绑定中提供指向相应C++函数的指针。

### Node如何确定接下来要运行的代码？

理论上，Event Loop 和 Worker Pool 分别操作待处理的事件 和 待完成的任务。

实际上，Event Loop并不真正维护队列。相应的，它有一组文件描述符，这些文件描述符被操作系统使用epoll（Linux），kqueue（OSX），事件端口（Solaris）或IOCP（Windows）等机制进行监视。这些文件描述符对应于网络套接字，它正在观看的任何文件，等等。当操作系统说其中一个文件描述符准备就绪时，Event Loop会将其转换为相应的事件并调用与该事件关联的回调。您可以在[此处](https://www.youtube.com/watch?v=P9csgxBgaZ8)详细了解此过程。

相反，Worker Pool使用一个真正的队列，队列中包含要处理的任务。Worker从此队列中出栈一个任务并对其进行处理，完成后，Worker会为事件循环引发“至少一个任务已完成”事件。

### 这对应用程序设计意味着什么？
在像Apache这样的一个线程对应一个客户端连接的系统中，每个挂起的客户端都被分配了自己的线程。如果处理一个客户端的线程阻塞时，操作系统会中断它并切换到另一个处理客户端请求的线程。因此操作系统确保需要少量工作的客户不会受到需要更多工作的客户的影响。

因为Node用很少的线程数量处理许多客户端连接，如果一个线程处理一个客户端的请求时被阻塞，那么其它被挂起的客户端请求会一直得不到执行机会，直到该线程完成其回调或任务。 *因此，保证客户端的连接都受到公平对待是你编写程序的工作内容。*  这也就是说，在Node 程序中，不应该在任何单个回调或任务中为任何客户端做太多比较耗时的工作。

上面说的就是Node为什么可以很好地扩展的部分原因，但这也意味着开发者有责任确保公平的调度。接下来的部分将讨论如何确保事件循环和工作池的公平调度。


## 不要阻塞事件循环

事件循环通知每个新客户端连接并协调对客户端的响应。也就是说，所有传入请求和传出响应都通过事件循环处理。这意味着如果事件循环在任何时候花费的时间太长，所有当前的 以及新进来的客户端连接都不会获得响应机会。

所以，要确保在任何时候都不应该阻塞事件循环。换句话说，每一个JavaScript回调应当能够快速完成。这当然也适用于你`await`，`Promise.then`等。

确保这一点的一个好方法是推断回调的“计算复杂度”。如果你的回调需要一定数量的步骤，无论它的参数是什么，总是会给每个连接的客户段提供一个合理的响应。如果回调根据其参数采用不同的步骤数，那么就应该考虑不同参数可能导致的计算复杂度。

例子1： 恒定时间的回调

``` javascript
app.get('/constant-time', (req, res) => {
    res.sendStatus(200);
});
```

例子2： 时间复杂度O(n)。回调运行时间与n成线性关系

``` javascript
app.get('/countToN', (req, res) => {
    let n = req.query.n;

    // n iterations before giving someone else a turn
    for (let i = 0; i < n; i++) {
        console.log(`Iter {$i}`);
    }

    res.sendStatus(200);
});
```

例子3： 时间复杂度是O(n^2)的例子。当n比较小的时候，回调执行速度没有太大的影响，如果n比较大，相对O(n)而言，会特别的慢。而且n+1 对 n而言，执行时间也会增长很多。是指数级别的。

``` javascript
app.get('/countToN2', (req, res) => {
    let n = req.query.n;

    // n^2 iterations before giving someone else a turn
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            console.log(`Iter ${i}.${j}`);
        }
    }

    res.sendStatus(200);
});
```

### 如何更小心一点？
Node使用Google V8引擎解析JavaScript，这对于许多常见操作来说非常快。但是有例外：regexp和JSON操作。

对于复杂的任务，应该考虑限制输入长度并拒绝太长的输入。这样，即使回调具有很大的复杂度，通过限制输入，也可以确保回调执行时间不会超过最坏情况下的执行时间。然后，可以依据此评估​​回调的最坏情况成本，并确定其上下文中的运行时间是否可接受。


### 阻止事件循环： REDOS(Regular expression Denial of Service - ReDoS)

一种比较常见的阻塞事件循环的方式是使用比较“脆弱”的正则表达式。

正则表达式（regexp）将输入字符串与特定的模式匹配。通常我们认为正则表达式只需要匹配一次输入的字符串----时间复杂度是O(n)，n是输入字符串的长度。在许多情况下，确实只需要一次便可完成匹配。但在某些情况下，正则表达式可能需要对传入的字符串进行多次匹配----时间复杂度是O(2^n)。指数级增长意味着如果引擎需要x次回溯来确定匹配，那么如果我们在输入字符串中再添加一个字符，则至少需要2*x次回溯。由于回溯次数与所需时间成线性关系，因此这种情况会阻塞事件循环。

一个“脆弱”的正则表达式在你的正则匹配引擎上运行可能需要指数时间，导致你可能遭受REDOS(Regular expression Denial of Service - ReDoS)的“邪恶输入”。但是正则表达式模式是否易受攻击（即正则表达式引擎可能需要指数时间）实际上是一个难以回答的问题，并且取决于您使用的是Perl，Python，Ruby，Java，JavaScript等。但有一些经验法则是适用于所有语言的：

1. 避免使用嵌套量词(a+)*。Node的regexp引擎可能可以快速处理其中的一些，但其他引擎容易受到攻击。
2. 避免使用带有重叠子句的OR，例如(a|a)*。同样，这种情况有时是快速的。
3. 避免使用反向引用，例如(a.*) \1。没有正则表达式引擎可以确保在线性时间内匹配它们。
4. 如果您正在进行简单的字符串匹配，请使用indexOf或其它本身替代方法。它会更轻量且永远不会超过O(n)。

如果您不确定您的正则表达式是否容易受到攻击，但你需要明确的是即使易受攻击的正则表达式和长输入字符串，Node通常无法报告匹配项。当不匹配时， Node在尝试匹配的输入字符串的许多路径之前，是无法确定是否会触发指数级的时间长度。

一个REDOS（Regular expression Denial of Service - ReDoS） 例子

以下是将其服务器暴露给REDOS的示例易受攻击的正则表达式：

``` javascript
app.get('/redos-me', (req, res) => {
    let filePath = req.query.filePath;

    // REDOS
    if (fileName.match(/(\/.+)+$/)) {
        console.log('valid path');
    }
    else {
        console.log('invalid path');
    }

    res.sendStatus(200);
});
```

这个例子中易受攻击的正则表达式是一种（糟糕的）方法来检查Linux上的有效路径。它匹配以“/”作为分隔符的字符串，如“/a/b/c”。它很危险，因为它违反了规则1：它有一个双重嵌套的量词。

如果客户端使用filePath查询///.../\n（100 / s后跟换行符“。”将不匹配的换行符），那么事件循环将永远有效，阻塞事件循环。此客户端的REDOS攻击导致所有其他客户端在regexp匹配完成之前不会响应。

因此，您应该谨慎使用复杂的正则表达式来验证用户输入。

#### 反REDOS资源

有一些工具可以检查你的regexp是否安全，比如

- [safe-regex](https://github.com/substack/safe-regex)
- [rxxr2](http://www.cs.bham.ac.uk/~hxt/research/rxxr2/)。
  
但是，它们并不能保证识别所有易受攻击的正则表达式。

另一种方法是使用不同的正则表达式引擎。您可以使用[node-re2](https://github.com/uhop/node-re2)模块，该模块使用Google非常火热的[RE2](https://github.com/google/re2) regexp引擎。但是要注意，RE2与Node的regexp不是100％兼容，因此如果你使用node-re2模块来处理你的regexp，请检查回归。node-re2不支持特别复杂的regexp。

如果您正在尝试匹配一些特别常见的内容，例如URL或文件路径，请在[regexp库](http://www.regexlib.com/)中查找示例或使用npm模块，例如[ip-regex](https://www.npmjs.com/package/ip-regex)。

### 阻止事件循环：Node核心模块
Node中有几个核心模块具有同步版本的开销比较大的API，包括：

- [encryption](https://nodejs.org/api/crypto.html)
- [compression](https://nodejs.org/api/zlib.html)
- [File System](https://nodejs.org/api/zlib.html)
- [Child Process](https://nodejs.org/api/child_process.html)


这些API很昂贵，因为它们涉及大量计算（encryption加密，compression压缩），需要I/O（文件I/O），或者上述两者都有（Child Process）。这些API本来的目的是方便脚本编写，但它们并不适用于服务器的上下文环境。如果在事件循环上执行它们，它们将比普通的JavaScript指令花费更长的时间来完成，从而导致事件循环过程产生阻塞。

在服务器中，您不应使用以下模块中的以下同步API：

- encryption：
    - `crypto.randomBytes`（同步版）
    - `crypto.randomFillSync`
    - `crypto.pbkdf2Sync`
    - 您还应该注意为加密和解密例程提供大量输入。
- compression：
    - `zlib.inflateSync`
    - `zlib.deflateSync`
- 文件系统：
    - 不要使用同步文件系统API。例如，如果您访问的文件位于NFS等分布式文件系统中，则访问时间可能会有很大差异。
- Child Process：
    - `child_process.spawnSync`
    - `child_process.execSync`
    - `child_process.execFileSync`


从Node v9开始，此列表相当完整。

### 阻止事件循环：JSON DOS
JSON.parse和JSON.stringify是另外两种可能耗时 比较长的的操作。虽然它们的时间复杂度都是O(n)，但是对于比较大的n来说，它们可能需要很长时间进行处理。

如果您的服务器操纵JSON对象，特别是来自客户端的JSON对象，您应该对在Event Loop上使用的对象或字符串的大小保持谨慎。

JSON 阻塞示例：我们创建一个大小为2 ^ 21 的obj对象，然后在字符串上JSON.stringify运行indexOf，然后运行JSON.parse。该JSON.stringify“d字符串为50MB。字符串化对象需要0.7秒，对50MB字符串的indexOf需要0.03秒，解析字符串需要1.3秒。

``` javascript
var obj = { a: 1 };
var niter = 20;

var before, res, took;

for (var i = 0; i < len; i++) {
  obj = { obj1: obj, obj2: obj }; // Doubles in size each iter
}

before = process.hrtime();
res = JSON.stringify(obj);
took = process.hrtime(n);
console.log('JSON.stringify took ' + took);

before = process.hrtime();
res = str.indexOf('nomatch');
took = process.hrtime(n);
console.log('Pure indexof took ' + took);

before = process.hrtime();
res = JSON.parse(str);
took = process.hrtime(n);
console.log('JSON.parse took ' + took);

```

有一些npm模块提供异步JSON API。参见例如：

- 具有流API[JSONStream](https://www.npmjs.com/package/JSONStream)
- [Big-Friendly JSON](https://github.com/philbooth/bfj)，它具有流API以及标准JSON API的异步版本，使用下面概述的事件循环分区。


### 复杂计算而不阻塞事件循环
假设您想在JavaScript中执行复杂计算而不阻塞事件循环。您有两种选择：partitioning切割或offloading转嫁。

**partitioning切割**
您可以对计算进行分区，以便每个计算都在事件循环上运行，但会定期产生（转向）其他待处理事件。在JavaScript中，很容易在闭包中保存正在进行的任务的状态，如下面的示例2所示。

举个简单的例子，假设你想要的数字的平均计算1到n。

示例1：未做分割的情况，平均成本 O(n)：

``` javascript

for (let i = 0; i < n; i++)
  sum += i;
let avg = sum / n;
console.log('avg: ' + avg);
```
示例2：分割求平均值，每个n异步步骤的成本O(1)。

``` javascript
function asyncAvg(n, avgCB) {
  // Save ongoing sum in JS closure.
  var sum = 0;
  function help(i, cb) {
    sum += i;
    if (i == n) {
      cb(sum);
      return;
    }

    // "Asynchronous recursion".
    // Schedule next operation asynchronously.
    setImmediate(help.bind(null, i+1, cb));
  }

  // Start the helper, with CB to call avgCB.
  help(1, function(sum){
      var avg = sum/n;
      avgCB(avg);
  });
}

asyncAvg(n, function(avg){
  console.log('avg of 1-n: ' + avg);
});
```

您可以将此原则应用于数组迭代等。

**offloading**
如果您需要做一些更复杂的事情，partitioning也许不是一个好选择。这是因为partitioning仅借助于事件循环。而您几乎无法使用多核系统。 请记住，事件循环应该是调度客户端请求，而不是自己完成它们。 对于复杂的任务，可将工作的转嫁到工​​作池上。

**How to offloading**
对于要卸载工作的目标工作线池，您有两个选项。

- 您可以通过开发C++插件来使用内置的Node Worker Pool 。在旧版本的Node上，使用NAN构建C++插件，在较新版本上使用N-API。`node-webworker-threads`提供了一种访问Node的Worker Pool的JavaScript方法。
- 您可以创建和管理专用于计算的工作池，而不是Node的I/O主题工作池。最直接的方法是使用子进程或群集。你应该不是简单地创建一个子进程为每个客户端。您可以比创建和管理子项更快地接收客户端请求，并且您的服务器可能会成为一个分叉炸弹。

**offloading的缺点**
offloading方法的缺点是它会产生通信成本。只允许Event Loop查看应用程序的“namespace”（JavaScript状态）。从Worker中，您无法在Event Loop的命名空间中操作JavaScript对象。相反，您必须序列化和反序列化您希望共享的任何对象。然后，Worker可以对它们自己的这些对象的副本进行操作，并将修改后的对象（或“补丁”）返回给事件循环。

有关序列化问题，请参阅有关JSON DOS的部分。

**一些卸载的建议**
您可能希望区分CPU密集型和I/O密集型任务，因为它们具有明显不同的特征。

CPU密集型任务仅在调度其Worker时进行，并且必须将Worker调度到计算机的一个逻辑核心上。如果您有4个逻辑核心和5个工作者，则其中一个工作者无法取得进展。因此，您为此Worker支付了开销（内存和调度成本），并且没有获得任何回报。

I/O密集型任务涉及查询外部服务提供商（DNS，文件系统等）并等待其响应。虽然具有I/O密集型任务的Worker正在等待其响应，但它没有其他任何操作可以由操作系统取消调度，从而使另一个Worker有机会提交其请求。因此，即使关联的线程未运行，I/O密集型任务也将取得进展。数据库和文件系统等外部服务提供商已经过高度优化，可以同时处理许多待处理的请求。例如，文件系统将检查大量待处理的写入和读取请求，以合并冲突的更新并以最佳顺序检索文件（例如，请参阅这些幻灯片）。

如果您只依赖一个工作池，例如Node Worker Pool，那么CPU绑定和I/O绑定工作的不同特性可能会损害您的应用程序的性能。

因此，您可能希望维护一个单独的Computation Worker Pool。

**offloadin结论**
对于简单的任务，例如迭代任意长数组的元素，partitioning可能是一个不错的选择。如果您的计算更复杂，则offloading是一种更好的方法：通信成本，即在事件循环和工作池之间传递序列化对象的开销，会被使用多个核心的好处所抵消。

但是，如果您的服务器在很大程度上依赖于复杂的计算，那么您应该考虑Node是否真的适合。Node擅长I/O操作相关的工作，但对于复杂的计算，它可能不是最好的选择。

如果您采用offloading方法，请参阅有关不阻止工作池的部分。