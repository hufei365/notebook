# 不要阻塞事件循环（或工作池）

## 你应该阅读本指南吗？
如果您编写比命令行脚本更复杂的程序，那么阅读本文可以帮助您编写性能更高，更安全的应用程序。

在编写本文档时，主要是基于Node服务器。但里面的原则也适用于其它复杂的Node应用程序。在没有特别说明操作系统的情况下，默认为Linux。

## TL; DR
Node.js在事件循环（初始化和回调）中运行JavaScript代码，并提供工作池来处理成本比较高的任务，如文件I/O。 Node服务节点有很强的扩展能力，有时能提供比相对较重的Apache更好的解决方案。关键点就在于它使用少量线程来处理多客户端连接。如果Node可以使用更少的线程，那么它可以将更多的系统时间和内存用于客户端，而不是为线程（内存，上下文切换）占用额外空间和时间。但也因为Node只有少量的线程，因此在构建应用程序时，必须明智地使用它们。


这里有一些保持Node服务器快速稳健运行的经验法则： 当在任何给定时间与每个客户端关联的工作“很小”时，Node服务会很快。

这适用于事件循环上的回调和工作池上的任务。

## 为什么我要避免阻塞事件循环和工作池？
Node使用少量的线程来处理多个客户端连接。在Node中有两种类型的线程：

- 一个事件循环（又称主循环，主线程，事件线程等）；
- `k`工作池（也称为线程池）中的工作池

如果一个线程需要很长时间来执行回调（Event Loop）或任务（Worker），我们称之为“阻塞”。虽然线程为处理一个客户端连接而阻塞，但它无法处理来自任何其他客户端的请求。这提供了阻止事件循环和工作池的两个动机：

1. **性能**：如果经常在任一类型的线程上执行重量级活动，则服务器的吞吐量（请求/秒）将受到影响；
2. **安全性**：如果某个输入可能会阻塞某个线程，则恶意客户端可能会提交此“恶意输入”，使线程阻塞，从而阻塞其它客户端上的处理。这就很方便地的造成了 **拒绝服务攻击**。


## 快速回顾一下Node
Node使用事件驱动架构：它有一个事件循环用于调度 和 一个处理阻塞任务的工作池。

### 什么代码在事件循环上运行？
在开始时，Node应用程序首先完成初始化阶段，即require模块和注册事件的回调。然后，Node应用程序进入事件循环，通过执行相应的回调来响应传入的客户端请求。此回调同步执行，并在完成后又有可能注册新的异步请求。这些新异步请求的回调也将在事件循环上执行。

事件循环中还包含其它一些非阻塞异步请求（例如，网络I/O）产生的回调。

总之，Event Loop执行这些注册为某些事件的JavaScript回调，并且还负责完成非阻塞异步请求，如网络I/O.


### 什么代码在线程池（Worker Pool）中运行

Node的线程池通过`libuv`([docs](http://docs.libuv.org/en/v1.x/threadpool.html))实现。`libuv`暴露出一组任务提交的API。

Node使用线程池（Worker Pool）处理比较费时的任务。例操作系统没有提供非阻塞版本的I/O, CPU密集型任务等。

会用到线程池的Node模块：

- I/O密集型
    - DNS: `dns.lookup()`, `dns.lookupService()`
    - fs: 除了`fs.FSWatcher()`和所有明确同步调用的文件API，剩下的都会用到libuv实现的线程池
- CPU密集型
    - Crypto: `crypto.pbkdf2()`, `crypto.randomBytes()`, `crypto.randomFill()`
    - Zlib: 除了明确声明使用同步调用的API，剩下的都会用到libuv的线程池


在大多数Node应用程序中，这些API是Worker Pool的唯一任务源。实际上，使用C++插件的应用程序和模块也可以提交任务给工作池。

为了完整起见，我们注意到当从事件循环上的回调中调用上述其中一个API时，事件循环会花费一些较小的设置成本。因为需要进入该API相关的C++实现模块并将任务提交给工作池。与任务的总成本相比，这些成本可以忽略不计，这就是事件循环将它转接到C++模块的原因。将这些任务之一提交给Worker Pool时，Node会在Node C++绑定中提供指向相应C++函数的指针。

### Node如何确定接下来要运行的代码？

理论上，Event Loop 和 Worker Pool 分别操作待处理的事件 和 待完成的任务。

实际上，Event Loop并不真正维护队列。相应的，它有一组文件描述符，这些文件描述符被操作系统使用epoll（Linux），kqueue（OSX），事件端口（Solaris）或IOCP（Windows）等机制进行监视。这些文件描述符对应于网络套接字，它正在观看的任何文件，等等。当操作系统说其中一个文件描述符准备就绪时，Event Loop会将其转换为相应的事件并调用与该事件关联的回调。您可以在[此处](https://www.youtube.com/watch?v=P9csgxBgaZ8)详细了解此过程。

相反，Worker Pool使用一个真正的队列，队列中包含要处理的任务。Worker从此队列中出栈一个任务并对其进行处理，完成后，Worker会为事件循环引发“至少一个任务已完成”事件。

### 这对应用程序设计意味着什么？
在像Apache这样的一个线程对应一个客户端连接的系统中，每个挂起的客户端都被分配了自己的线程。如果处理一个客户端的线程阻塞时，操作系统会中断它并切换到另一个处理客户端请求的线程。因此操作系统确保需要少量工作的客户不会受到需要更多工作的客户的影响。

因为Node用很少的线程数量处理许多客户端连接，如果一个线程处理一个客户端的请求时被阻塞，那么其它被挂起的客户端请求会一直得不到执行机会，直到该线程完成其回调或任务。 *因此，保证客户端的连接都受到公平对待是你编写程序的工作内容。*  这也就是说，在Node 程序中，不应该在任何单个回调或任务中为任何客户端做太多比较耗时的工作。

上面说的就是Node为什么可以很好地扩展的部分原因，但这也意味着开发者有责任确保公平的调度。接下来的部分将讨论如何确保事件循环和工作池的公平调度。


## 不要阻塞事件循环

事件循环通知每个新客户端连接并协调对客户端的响应。也就是说，所有传入请求和传出响应都通过事件循环处理。这意味着如果事件循环在任何时候花费的时间太长，所有当前的 以及新进来的客户端连接都不会获得响应机会。

所以，要确保在任何时候都不应该阻塞事件循环。换句话说，每一个JavaScript回调应当能够快速完成。这当然也适用于你`await`，`Promise.then`等。

确保这一点的一个好方法是推断回调的“计算复杂度”。如果你的回调需要一定数量的步骤，无论它的参数是什么，总是会给每个连接的客户段提供一个合理的响应。如果回调根据其参数采用不同的步骤数，那么就应该考虑不同参数可能导致的计算复杂度。

例子1： 恒定时间的回调

``` javascript
app.get('/constant-time', (req, res) => {
    res.sendStatus(200);
});
```

例子2： 时间复杂度O(n)。回调运行时间与n成线性关系

``` javascript
app.get('/countToN', (req, res) => {
    let n = req.query.n;

    // n iterations before giving someone else a turn
    for (let i = 0; i < n; i++) {
        console.log(`Iter {$i}`);
    }

    res.sendStatus(200);
});
```

例子3： 时间复杂度是O(n^2)的例子。当n比较小的时候，回调执行速度没有太大的影响，如果n比较大，相对O(n)而言，会特别的慢。而且n+1 对 n而言，执行时间也会增长很多。是指数级别的。

``` javascript
app.get('/countToN2', (req, res) => {
    let n = req.query.n;

    // n^2 iterations before giving someone else a turn
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            console.log(`Iter ${i}.${j}`);
        }
    }

    res.sendStatus(200);
});
```

### 如何更小心一点？
Node使用Google V8引擎解析JavaScript，这对于许多常见操作来说非常快。但是有例外：regexp和JSON操作。

对于复杂的任务，应该考虑限制输入长度并拒绝太长的输入。这样，即使回调具有很大的复杂度，通过限制输入，也可以确保回调执行时间不会超过最坏情况下的执行时间。然后，可以依据此评估​​回调的最坏情况成本，并确定其上下文中的运行时间是否可接受。


### 阻止事件循环： REDOS(Regular expression Denial of Service - ReDoS)

一种比较常见的阻塞事件循环的方式是使用比较“脆弱”的正则表达式。

正则表达式（regexp）将输入字符串与特定的模式匹配。通常我们认为正则表达式只需要匹配一次输入的字符串----时间复杂度是O(n)，n是输入字符串的长度。在许多情况下，确实只需要一次便可完成匹配。但在某些情况下，正则表达式可能需要对传入的字符串进行多次匹配----时间复杂度是O(2^n)。指数级增长意味着如果引擎需要x次回溯来确定匹配，那么如果我们在输入字符串中再添加一个字符，则至少需要2*x次回溯。由于回溯次数与所需时间成线性关系，因此这种情况会阻塞事件循环。

一个“脆弱”的正则表达式在你的正则匹配引擎上运行可能需要指数时间，导致你可能遭受REDOS(Regular expression Denial of Service - ReDoS)的“邪恶输入”。但是正则表达式模式是否易受攻击（即正则表达式引擎可能需要指数时间）实际上是一个难以回答的问题，并且取决于您使用的是Perl，Python，Ruby，Java，JavaScript等。但有一些经验法则是适用于所有语言的：

1. 避免使用嵌套量词(a+)*。Node的regexp引擎可能可以快速处理其中的一些，但其他引擎容易受到攻击。
2. 避免使用带有重叠子句的OR，例如(a|a)*。同样，这种情况有时是快速的。
3. 避免使用反向引用，例如(a.*) \1。没有正则表达式引擎可以确保在线性时间内匹配它们。
4. 如果您正在进行简单的字符串匹配，请使用indexOf或其它本身替代方法。它会更轻量且永远不会超过O(n)。

如果您不确定您的正则表达式是否容易受到攻击，但你需要明确的是即使易受攻击的正则表达式和长输入字符串，Node通常无法报告匹配项。当不匹配时， Node在尝试匹配的输入字符串的许多路径之前，是无法确定是否会触发指数级的时间长度。

一个REDOS（Regular expression Denial of Service - ReDoS） 例子

以下是将其服务器暴露给REDOS的示例易受攻击的正则表达式：

``` javascript
app.get('/redos-me', (req, res) => {
    let filePath = req.query.filePath;

    // REDOS
    if (fileName.match(/(\/.+)+$/)) {
        console.log('valid path');
    }
    else {
        console.log('invalid path');
    }

    res.sendStatus(200);
});
```

这个例子中易受攻击的正则表达式是一种（糟糕的）方法来检查Linux上的有效路径。它匹配以“/”作为分隔符的字符串，如“/a/b/c”。它很危险，因为它违反了规则1：它有一个双重嵌套的量词。

如果客户端使用filePath查询///.../\n（100 / s后跟换行符“。”将不匹配的换行符），那么事件循环将永远有效，阻塞事件循环。此客户端的REDOS攻击导致所有其他客户端在regexp匹配完成之前不会响应。

因此，您应该谨慎使用复杂的正则表达式来验证用户输入。

#### 反REDOS资源

有一些工具可以检查你的regexp是否安全，比如

- [safe-regex](https://github.com/substack/safe-regex)
- [rxxr2](http://www.cs.bham.ac.uk/~hxt/research/rxxr2/)。
  
但是，它们并不能保证识别所有易受攻击的正则表达式。

另一种方法是使用不同的正则表达式引擎。您可以使用[node-re2](https://github.com/uhop/node-re2)模块，该模块使用Google非常火热的[RE2](https://github.com/google/re2) regexp引擎。但是要注意，RE2与Node的regexp不是100％兼容，因此如果你使用node-re2模块来处理你的regexp，请检查回归。node-re2不支持特别复杂的regexp。

如果您正在尝试匹配一些特别常见的内容，例如URL或文件路径，请在[regexp库](http://www.regexlib.com/)中查找示例或使用npm模块，例如[ip-regex](https://www.npmjs.com/package/ip-regex)。