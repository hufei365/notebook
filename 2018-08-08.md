# 不要阻塞事件循环（或工作池）

## 你应该阅读本指南吗？
如果您编写比命令行脚本更复杂的程序，那么阅读本文可以帮助您编写性能更高，更安全的应用程序。

在编写本文档时，主要是基于Node服务器。但里面的原则也适用于其它复杂的Node应用程序。在没有特别说明操作系统的情况下，默认为Linux。

## TL; DR
Node.js在事件循环（初始化和回调）中运行JavaScript代码，并提供工作池来处理成本比较高的任务，如文件I/O。 Node服务节点有很强的扩展能力，有时能提供比相对较重的Apache更好的解决方案。关键点就在于它使用少量线程来处理多客户端连接。如果Node可以使用更少的线程，那么它可以将更多的系统时间和内存用于客户端，而不是为线程（内存，上下文切换）占用额外空间和时间。但也因为Node只有少量的线程，因此在构建应用程序时，必须明智地使用它们。


这里有一些保持Node服务器快速稳健运行的经验法则： 当在任何给定时间与每个客户端关联的工作“很小”时，Node服务会很快。

这适用于事件循环上的回调和工作池上的任务。

## 为什么我要避免阻塞事件循环和工作池？
Node使用少量的线程来处理多个客户端连接。在Node中有两种类型的线程：

- 一个事件循环（又称主循环，主线程，事件线程等）；
- `k`工作池（也称为线程池）中的工作池

如果一个线程需要很长时间来执行回调（Event Loop）或任务（Worker），我们称之为“阻塞”。虽然线程为处理一个客户端连接而阻塞，但它无法处理来自任何其他客户端的请求。这提供了阻止事件循环和工作池的两个动机：

1. **性能**：如果经常在任一类型的线程上执行重量级活动，则服务器的吞吐量（请求/秒）将受到影响；
2. **安全性**：如果某个输入可能会阻塞某个线程，则恶意客户端可能会提交此“恶意输入”，使线程阻塞，从而阻塞其它客户端上的处理。这就很方便地的造成了 **拒绝服务攻击**。


## 快速回顾一下Node
Node使用事件驱动架构：它有一个事件循环用于调度 和 一个处理阻塞任务的工作池。

### 什么代码在事件循环上运行？
在开始时，Node应用程序首先完成初始化阶段，即require模块和注册事件的回调。然后，Node应用程序进入事件循环，通过执行相应的回调来响应传入的客户端请求。此回调同步执行，并在完成后又有可能注册新的异步请求。这些新异步请求的回调也将在事件循环上执行。

事件循环中还包含其它一些非阻塞异步请求（例如，网络I/O）产生的回调。

总之，Event Loop执行这些注册为某些事件的JavaScript回调，并且还负责完成非阻塞异步请求，如网络I/O.


### 什么代码在线程池（Worker Pool）中运行

Node的线程池通过`libuv`([docs](http://docs.libuv.org/en/v1.x/threadpool.html))实现。`libuv`暴露出一组任务提交的API。

Node使用线程池（Worker Pool）处理比较费时的任务。例操作系统没有提供非阻塞版本的I/O, CPU密集型任务等。

会用到线程池的Node模块：

- I/O密集型
    - DNS: `dns.lookup()`, `dns.lookupService()`
    - fs: 除了`fs.FSWatcher()`和所有明确同步调用的文件API，剩下的都会用到libuv实现的线程池
- CPU密集型
    - Crypto: `crypto.pbkdf2()`, `crypto.randomBytes()`, `crypto.randomFill()`
    - Zlib: 除了明确声明使用同步调用的API，剩下的都会用到libuv的线程池


在大多数Node应用程序中，这些API是Worker Pool的唯一任务源。实际上，使用C++插件的应用程序和模块也可以提交任务给工作池。

为了完整起见，我们注意到当从事件循环上的回调中调用上述其中一个API时，事件循环会花费一些较小的设置成本。因为需要进入该API相关的C++实现模块并将任务提交给工作池。与任务的总成本相比，这些成本可以忽略不计，这就是事件循环将它转接到C++模块的原因。将这些任务之一提交给Worker Pool时，Node会在Node C++绑定中提供指向相应C++函数的指针。

### Node如何确定接下来要运行的代码？

理论上，Event Loop 和 Worker Pool 分别操作待处理的事件 和 待完成的任务。

实际上，Event Loop并不真正维护队列。相应的，它有一组文件描述符，这些文件描述符被操作系统使用epoll（Linux），kqueue（OSX），事件端口（Solaris）或IOCP（Windows）等机制进行监视。这些文件描述符对应于网络套接字，它正在观看的任何文件，等等。当操作系统说其中一个文件描述符准备就绪时，Event Loop会将其转换为相应的事件并调用与该事件关联的回调。您可以在[此处](https://www.youtube.com/watch?v=P9csgxBgaZ8)详细了解此过程。

相反，Worker Pool使用一个真正的队列，队列中包含要处理的任务。Worker从此队列中出栈一个任务并对其进行处理，完成后，Worker会为事件循环引发“至少一个任务已完成”事件。

### 这对应用程序设计意味着什么？
在像Apache这样的一个线程对应一个客户端连接的系统中，每个挂起的客户端都被分配了自己的线程。如果处理一个客户端的线程阻塞时，操作系统会中断它并切换到另一个处理客户端请求的线程。因此操作系统确保需要少量工作的客户不会受到需要更多工作的客户的影响。

因为Node用很少的线程数量处理许多客户端连接，如果一个线程处理一个客户端的请求时被阻塞，那么其它被挂起的客户端请求会一直得不到执行机会，直到该线程完成其回调或任务。 *因此，保证客户端的连接都受到公平对待是你编写程序的工作内容。*  这也就是说，在Node 程序中，不应该在任何单个回调或任务中为任何客户端做太多比较耗时的工作。

上面说的就是Node为什么可以很好地扩展的部分原因，但这也意味着开发者有责任确保公平的调度。接下来的部分将讨论如何确保事件循环和工作池的公平调度。


## 不要阻塞事件循环

事件循环通知每个新客户端连接并协调对客户端的响应。也就是说，所有传入请求和传出响应都通过事件循环处理。这意味着如果事件循环在任何时候花费的时间太长，所有当前的 以及新进来的客户端连接都不会获得响应机会。

所以，要确保在任何时候都不应该阻塞事件循环。换句话说，每一个JavaScript回调应当能够快速完成。