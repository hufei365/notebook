### Reflect

Reflect 是ES6中新增的特性。它是一个普通对象，下面有13个静态方法（`enumerate`在最终的发布版中被移除），可以再全局下访问。它不能当做函数调用，也不可以用`new`操作符生成一个实例。

首先来说，Reflect的提出是为了整合之前JS中存在的一些不太合理的地方。

1）**更加有用的返回值**

``` javascript
Object.getOwnPropertyNames(Reflect)
// ["defineProperty", "deleteProperty", "apply", "construct", "get", "getOwnPropertyDescriptor", "getPrototypeOf", "has", "isExtensible", "ownKeys", "preventExtensions", "set", "setPrototypeOf"]
```

#### Reflect.apply
功能跟`Function.prototype.apply`类似。

``` javascript
var a = [1,2,3];
Math.max.apply(null, a);// 3
Reflect.apply(Math.max, null, a); // 3
```

#### Reflect.isExtensible / Reflect.preventExtensions
 Reflect.preventExtensions用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。
Reflect.isExtensible表示当前对象是否可扩展， 返回一个布尔值。

``` javascript
var o = {};

Reflect.isExtensible(o);// true
Object.isExtensible(o);// true

Object.freeze(o);

Reflect.isExtensible(o);// false
Object.isExtensible(o);// false

// 这两方法的区别
Object.isExtensible(1) // false
Reflect.isExtensible(1) // 报错

var newO = {};
Reflect.isExtensible(newO);// true
Reflect.preventExtensions(newO); // true   返回true，表示该操作成功
Reflect.isExtensible(newO);// false
```

#### Reflect.set / Reflect.get
设置和获取对象属性, 这两个方法还允许接受一个reciever，用于重定义setter和getter方法的上下文。

``` javascript
var o = {};
Reflect.set(o, 'key', 'value');
console.log(o); // {key: "value"}

Reflect.get(o, 'key'); // "value"
Reflect.get(o, 'nokey'); // undefined
```

**下面演示一下receiver的使用方法**

``` javascript

var o = {
    name: 'O'
}

Object.defineProperty(o, 'sayHi', {
	get(){
		return 'hi, I am ' + this.name
	}
})

o.sayHi; // "hi, I am O"

var receiver = {
    name: 'receiver'
}
// 下面是关键， 看好咯~
Reflect.get(o, 'sayHi', receiver); // "hi, I am receiver"

// 下面试验了下Proxy的用法，可以忽略
var p = new Proxy(o, {
    get(o, k, p){
        return o[k] ? Reflect.get(o, k, receiver) : undefined;
    },
    set(o, k, v, p){
        v += +new Date();
        Reflect.set(o, k, v, p)
    }
});
p.sayHi; // "hi, I am receiver"
p.t = 'time:';
p.t; // "time:1530865528713"

```

#### Reflect.ownKeys
Reflect.ownKeys方法用于返回对象的所有属性数组。
这个数组的排序是根据: 先显示数字， 数字根据大小排序，然后是 字符串根据插入的顺序排序， 最后是symbol类型的key也根据插入插入顺序排序。
出现这种排序是因为，你给一个对象属性赋值时候， 对象的key的排序规则就是先数字， 在字符串， 最后是symbol类型的数据。

``` javascript
Reflect.ownKeys(JSON); // ["parse", "stringify", Symbol(Symbol.toStringTag)]
Object.getOwnPropertyNames(JSON); // ["parse", "stringify"]
Object.getOwnPropertySymbols(JSON); // [Symbol(Symbol.toStringTag)]
```

#### Reflect.has
用于判断对象是否具有某个属性

``` javascript
Reflect.has(JSON, 'parse'); // true
Reflect.has(JSON, 'nokeyxx'); // false
Reflect.has(1, 'parse');// Uncaught TypeError: Reflect.has called on non-object
```

#### Reflect.construct
功能类似于`new`操作符

``` javascript
var a = new Array(3);
console.log(a); // [empty × 3]

var b =  Reflect.construct(Array, [3])
console.log(b); // [empty × 3]
```

#### Reflect.defineProperty / Reflect.deleteProperty
Reflect.defineProperty 对应于Object.DefineProperty;
Reflect.deleteProperfy 对应于 `delete` 语句；

``` javascript
var o = {};
Object.defineProperty(o, 'sayHi', {
    configurable: true,
    get(k){
        return this[k] ? "Hi, I am " + this[k] : 'I have no name';
    }
});

o.sayHi;// "I have no name"

Reflect.defineProperty(o, 'sayHello', {
    configurable: true,
    get(k){
        return this[k] ? "Hi, I am " + this[k] : 'I have no name';
    }
})
o.sayHello; // "I have no name"

//  演示属性删除方法
delete o.sayHi; // true
Reflect.deleteProperty(o, 'sayHello'); // true

```

#### Reflect.setPrototypeOf / Reflect.getPrototypeOf
这两个方法用于设置和访问对象的原型`__proto__`

``` javascript
function A(){}; 
A.prototype.name= "A";
Reflect.getPrototypeOf(A)
// ƒ () { [native code] }

var a = new A();
Reflect.getPrototypeOf(a)
// {name: "A", constructor: ƒ}

a.name; // "A"


var c = {};
Reflect.setPrototypeOf(c, A.prototype);
c.name; // "A"
A.prototype.newName = "C";
c.newName; // "C"
```

#### Reflect.getOwnPropertyDescriptor
基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象。

``` javascript
Reflect.getOwnPropertyDescriptor(JSON, 'parse'); // {value: ƒ, writable: true, enumerable: false, configurable: true}
var c = {};
Reflect.defineProperty(c, 'name', {
    configurable: true,
    enumerable: true,
    value: 'CCC',
    writable: false
});

Reflect.getOwnPropertyDescriptor(c, 'name');  // {value: "CCC", writable: false, enumerable: true, configurable: true}

c.name; // "CCC"
c.name = 111;
c.name; // "CCC", 因为writable=== false
```




【参考资料】

[ecma 262：Reflect](http://www.ecma-international.org/ecma-262/6.0/#sec-reflection)

[为什么要使用Reflect的原因](https://github.com/tvcutsem/harmony-reflect/wiki#reflect)

[实例解析 ES6 Proxy 使用场景](http://pinggod.com/2016/%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-ES6-Proxy-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/)

