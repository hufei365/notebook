
> DOM2、DOM3 跟DOM1 相比，主要的变化？

DOM1 级主要定义的是 HTML 和 XML 文档的底层结构。DOM2 和 DOM3 级则在这个结构 的基础上引入了更多的交互能力， 也支持了更高级的 XML 特性。 为此， DOM2 和 DOM3 级分为许多模块（模块之间具有某种关联）， 分别描述了 DOM 的某个非常具体的子集。


1. 检测浏览器是否支持某个模块
2. DOM2 和 DOM2 实际上并没有增加新的特性，是在DOM1的基础上，对DOM做了功能扩展和增强。


### 针对XML，在命名空间上的变化
有了 XML 命名空间，不同 XML 文档的元素就可以混合在一起，共同构成格式良好的文档，而不 必担心发生命名冲突。从技术上说，HTML 不支持 XML 命名空间，但 XHTML 支持 XML 命名空间。

#### Node类型的变化
1.多出几个属性： 
- localName：不带命名空间前缀的节点名称；
- namespaceURI：命名空间URI，未制定情况下为null；
- prefix：命名空间前缀，未指定情况下位为null；

#### Document 类型的变化
主要是和Document下子节点有关的方法变化。
- createElementNS(namespaceURI, tagName)
- createAttributeNS(namespaceURI, attributeName)
- getElementsByTagNameNS(namespaceURI, tagName)

上面这几个方法都需要传入表示**命名空间**的 URI（是`http://www.w3.org/1999/xhtm` 这种类型的值, 而不是命名空间前缀）。

#### Element类型的变化
主要的变化是针对Element类型下 属性节点的操作，当然也包括其它的方法，例如getElementsByTagNameNS。
- getAttributeNS(namespaceURI,localName)：取得属于命名空间 namespaceURI 且名为localName 的特性。 
- getAttributeNodeNS(namespaceURI,localName)：取得属于命名空间 namespaceURI 且名为 localName 的特性节点。 
- getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间 namespaceURI的 tagName 元素的 NodeList。 
- hasAttributeNS(namespaceURI,localName)：确定当前元素是否有一个名为 localName的特性， 而且该特性的命名空间是 namespaceURI 。 注意，“DOM2 级核心”也增加了一个hasAttribute()方法，用于不考虑命名空间的情况。 
- removeAttriubteNS(namespaceURI,localName)：删除属于命名空间 namespaceURI 且名为 localName 的特性。 
- setAttributeNS(namespaceURI,qualifiedName,value)：设置属于命名空间 namespace-URI 且名为 qualifiedName 的特性的值为 value
- setAttributeNodeNS(attNode)：设置属于命名空间 namespaceURI 的特性节点。

这些方法的作用跟DOM1 中的方法，功能是相同的。不同的是参数。
``` html
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <title>DOM2 命名空间</title>
</head>

<body>
    <svg xmlns:s="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" style="width:100%; height:100%">
        <s:rect x="0" y="0" width="100" height="100" style="fill:red" /> </svg>
</body>
<script>
        const svg = document.getElementsByTagName('svg')[0];

        // 根据命名空间获取节点
        const rect = document.getElementsByTagNameNS('http://www.w3.org/2000/svg', 's:rect'); // rect 节点

        // Node类型的一些新增属性
        console.log(rect.localName); // s:rect  TODO: 存疑呢～～ 实际程序输出跟理解的不一致
        console.log(rect.namespaceURI); // http://www.w3.org/2000/svg
        console.log(rect.prefix); // null

        // Document 类型
        const svg_text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        svg_text.innerHTML = 'created by fn: createElementNS()'

        svg.appendChild(svg_text);

        // Element类型
        const svg_attr = document.createAttributeNS('http://www.w3.org/2000/svg', 'style');
        svg_attr.value = 'fill:red';
        svg_text.setAttributeNodeNS(svg_attr);

    </script>
</html>
```

### DOM2和DOM3中的样式

#### 访问样式
DOM中的样式分为三类：
1. 通过`<link>`标签引入的外部样式；
2. 通过`<style>`标签定义的样式；
3. 通过`style`属性定义的样式

在JavaScript中，可以通过Node的style属性访问元素的样式，但是这中方法无法访问到前两种方式定义的属性。 DOM2 增加了`getComputedStyle()`方法来获取这些样式。

DOM2 扩展了style 对象的一些属性和方法，通过这些属性和可以获取style对象的值以及它里面包含的一些CSS样式。

``` html
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <title>Style</title>
    <style>
        div{
            height: 123px;
            color: blue;
            text-align: center;
        }
    </style>
</head>

<body>
    <div style="width: 189px; height: 77px; back-ground: gray;">font color is blue</div>
</body>
<script>

        const div = document.getElementsByTagName('div')[0];

        console.log(div.style.color); // null
        console.log(div.style.textAlign); // null

        // getComputedStyle 方法
        const computeStyle  =  document.defaultView.getComputedStyle(div);

        console.log(computeStyle.color); // rgb(0, 0, 255)
        console.log(computeStyle.textAlign);  // center

        // style对象在DOM2中新增的一些特性
        console.log(div.style.getPropertyValue('height')); // "77px"
        console.log(div.style.removeProperty('height'));
        console.log(div.style.getPropertyValue('height')); // null

        // style 对象在DOM2中新增了一个length属性
        const len = div.style.length;
        for(let i = 0, s = div.style; i < len; i++){
            console.log(s[i]); // s[i]是属性名
        }

    </script>
</html>
```

*留一个问题思考：上例中，如果设置元素的`style=“background：red;”`, 那么通过 elem.style[i] 遍历输出style的样式属性都会有哪些？*

#### 操作样式

CSSStyleSheet 类型表示的是样式表，包括通过`<link>`元素包含的样式表和在`<style>`元素中定义 的样式表。

应用于文档的所有样式表是通过 **document.styleSheets** 集合来表示的。通过这个集合的 length 属性可以获知文档中样式表的数量。

每个样式表都有一个`cssRules`属性，这个属性包含这个样式表中所有定义的样式规则`cssRule`的集合。 `cssRule`表示样式表中的每一条规则。其中三个最常用的属性是 `cssText`、`selectorText` 和 `style`。cssText 属性与 style.cssText 属性类似，但并不相同。前者包含选择符文本和围绕样式信息的花括号，后者只包含样式信息（类似于 元素的 style.cssText）。此外，cssText 是只读的，而 style.cssText 也可以被重写。

每个样式表也可以动态地 **添加(insertRule)**或 **删除(deleteRule)**样式规则：
- insertRule(cssText, pos): 第一个参数是css样式的内容（p{color: red}）, 第二个参数表示插入的具体位置（也就是在cssRules列表中的位置），默认为0；
- deleteRule(pos): 参数pos表示规则的位置，跟insetRule中第二个参数的含义相同。

``` html 
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <title>DOM2 and Dom3</title>
    <link rel="stylesheet" href="style.css">
    <style>
        div {
            height: 123px;
            color: blue;
            text-align: center;
        }
        p{
            color: orchid;
            height: 40px;
        }
    </style>

    <style>
        span{
            font-size: 16px;
            color: red;
        }
    </style>
</head>

<body>
    <div style="width: 189px; height: 77px; background-color: gray;">font color is blue</div>

    <span>This is span text</span>

    <p>This text is p text</p>
</body>
<script>
    const allStyle = document.styleSheets; // 这是所有的样式表集合
    allStyle.length; // 3 个样式表， 分别一个link标签 和 两个style标签

    console.log(allStyle[0].href); // http://localhost/style.css
    const style1 = allStyle[1]; // 第一个style标签 声明的样式表

    console.log(style1.href); // null
    console.log(style1.cssRules[0].style.color); // "blue"
    console.log(style1.cssRules[1].style.color); // "orchid"
    console.log(style1.href);   // null

    // 创建规则 insertRule
    style1.insertRule('div.green{background-color: green;}');
    const newDiv = document.createElement('div');
    newDiv.innerHTML = "div with green background";
    newDiv.className = 'green';
    document.body.appendChild(newDiv);

    // 删除规则
    window.setTimeout(()=>{
        style1.deleteRule(0);
    }, 3000);

    
</script>

</html>
```

### 计算元素大小

#### 偏移量offset

有四个概念`offsetLeft`,`offsetTop`,`offsetWidth`,`offsetHeight`，看图说明一切

![偏移量](http://p9jftl6n6.bkt.clouddn.com/offset-x.png)

#### 客户区大小
元素的客户区大小（client dimension），指的是元素内容及其内边距所占据的空间大小。有关客户区 大小的属性有两个：clientWidth 和 clientHeight。其中，clientWidth 属性是元素内容区宽度加 上左右内边距宽度；clientHeight 属性是元素内容区高度加上上下内边距高度。

![客户区大小](http://p9jftl6n6.bkt.clouddn.com/client-x.png)

#### 滚动区域大小
- scrollHeight：在没有滚动条的情况下，元素内容的总高度。 
- scrollWidth：在没有滚动条的情况下，元素内容的总宽度。 
- scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。 
- scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。

![滚动区域大小](http://p9jftl6n6.bkt.clouddn.com/scroll-x.png)

#### getBoundingClientRect()方法
返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合, 即：是与该元素相关的CSS 边框集合 。

DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right和bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的。

当计算边界矩形时，会考虑视口区域（或其他可滚动元素）内的滚动操作，也就是说，当滚动位置发生了改变，top和left属性值就会随之立即发生变化（因此，它们的值是相对于视口的，而不是绝对的）。如果你需要获得相对于整个网页左上角定位的属性值，那么只要给top、left属性值加上当前的滚动位置（通过window.scrollX和window.scrollY），这样就可以获取与当前的滚动位置无关的值。

![getBoundingClientRect()](http://p9jftl6n6.bkt.clouddn.com/rect.png)



### 遍历
DOM2 提供的遍历节点有两个方法： `NodeIterator` 和 `TreeWalker`。

``` html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>walknode</title>
</head>

<body>
    <div>
        First Div Node
    </div>
    <ul>
        <li class="mark">
            <a href="#1">1</a>
            <span>1</span>
        </li>
        This is a Text Node.
        <li class="mark">
            <a href="#2">2</a>
        </li>
        <li class="mark">
            <a href="#3">3</a>
        </li>
    </ul>
    <p>
        This is a test paragraph.
    </p>

    <div id="div1">
        <p>
            <b>Hello</b> world!</p>
        <ul>
            <li>List item 1</li>
            <li>List item 2</li>
            <li>List item 3</li>
        </ul>
    </div>
    <script>
        const whatShow = NodeFilter.SHOW_ELEMENT;
        const iterator = document.createNodeIterator(document.body, whatShow);
        let n = null;
        while (n = iterator.nextNode()) {
            console.log(n);
        }

        // TreeWalker的用法
        const filter = (node) => {
            return node.tagName === 'UL';
        }
        const treewalker = document.createTreeWalker(document.body, whatShow, filter);
        while (n = treewalker.nextNode()) {
            console.log(n);
        }

        // TreeWalker与 NodeIterator不同的地方在于 TreeWalker能够在 DOM 结构中沿任何方向移动
        var div = document.getElementById("div1");
        var walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, null, false);

        walker.firstChild(); //转到<p> 
        walker.nextSibling(); //转到<ul> 

        var node = walker.firstChild(); //转到第一个<li> 
        while (node !== null) {
            console.log(node);
            node = walker.nextSibling();
        }
    </script>
</body>

</html>
```

### 范围

DOM2 级在 Document 类型中定义了 createRange()方法。在兼容 DOM 的浏览器中，这个方法属于 document 对象。使用 hasFeature()或者直接检测该方法，都可以确定浏览器是否支持范围。 

``` javascript
var supportsRange = document.implementation.hasFeature("Range", "2.0"); 
var alsoSupportsRange = (typeof document.createRange == "function"); 
```

如果浏览器支持范围，那么就可以使用 createRange()来创建 DOM 范围，如下所示： 

``` javascript 
var range = document.createRange(); 
```

与节点类似，新创建的范围也直接与创建它的文档关联在一起，不能用于其他文档。创建了范围之后，接下来就可以使用它在后台选择文档中的特定部分。而创建范围并设置了其位置之后，还可以针对范围的内容执行很多种操作，从而实现对底层 DOM 树的更精细的控制。 

每个范围由一个 Range 类型的实例表示，这个实例拥有很多属性和方法。下列属性提供了当前范围在文档中的位置信息。 

- startContainer：包含范围起点的节点（即选区中第一个节点的父节点）。 
- startOffset：范围在 startContainer 中起点的偏移量。如果 startContainer 是文本节点、注释节点或 CDATA 节点，那么 startOffset 就是范围起点之前跳过的字符数量。否则，startOffset 就是范围中第一个子节点的索引。 
- endContainer：包含范围终点的节点（即选区中最后一个节点的父节点）。 
- endOffset：范围在 endContainer 中终点的偏移量（与 startOffset 遵循相同的取值规则）。
- commonAncestorContainer：startContainer 和 endContainer 共同的祖先节点在文档树中位置最深的那个。 

在把范围放到文档中特定的位置时，这些属性都会被赋值。


#### 简单的DOM范围选择

最简的方式就是使用 `selectNode()`或`selectNodeContents()`。
两个方法都接受DOM节点作为参数，但是区别在于：`selectNode()`方法选择整个节点，包括其子节点；而 `selectNodeContents()`方法则只选择节点的
子节点。

``` html
<!DOCTYPE html> 
<html> 
    <body>     
        <p id="p1"><b>Hello</b> world!</p> 
        <script>
            var r1 = document.createRange();
            var r2 = document.createRange();
            var p = document.getElementById('p1');

            r1.selectNode(p); // 选择整个p节点
            r2.selectNodeContents(p);  // 只选择p节点下的子节点（<b>标签和文本节点world!）
        </script>
    </body> 
</html>
```

#### 复杂的DOM范围选择

复杂的范围选择，可能跨DOM节点，而且范围的开始位置也许只是在某个节点的中间位置。这时候需要用到的方法就是`setStart()` 和 `setEnd()` 。
``` html
<!DOCTYPE html>
<html>

<body>
    <p id="p1">
        <b>Hello</b> world!</p>
    <script>
        var r1 = document.createRange();
        var r2 = document.createRange();
        var p1 = document.getElementById('p1');

        var p1Index = -1;
        var i, len;
        
        for (i = 0, len = p1.parentNode.childNodes.length; i < len; i++) {
            if (p1.parentNode.childNodes[i] == p1) {
                p1Index = i;
                break;
            }
        }

        r1.setStart(p1.parentNode, p1Index);
        r1.setEnd(p1.parentNode, p1Index + 1);
        r2.setStart(p1, 0);
        r2.setEnd(p1, p1.childNodes.length);
    </script>
</body>

</html>
```


#### 操作 DOM 范围中的内容

`deleteContents()` 、 `extractContents()` 和 `cloneContents()`

``` html
<!DOCTYPE html>
<html>

<body>
    <p>The below content will be remove in <strong style="color: red;">three </strong> seconds.</p>
    <p id="p1">
        <b>Hello</b> world!</p>
    <script>
        var r1 = document.createRange();
        var r2 = document.createRange();
        var p1 = document.getElementById('p1');

        var p1Index = -1;
        var i, len;
        
        for (i = 0, len = p1.parentNode.childNodes.length; i < len; i++) {
            if (p1.parentNode.childNodes[i] == p1) {
                p1Index = i;
                break;
            }
        }

        r1.setStart(p1.parentNode, p1Index);
        r1.setEnd(p1.parentNode, p1Index + 1);
        r2.setStart(p1, 0);
        r2.setEnd(p1, p1.childNodes.length);

        setTimeout(()=>{
            r2.deleteContents();
        }, 3000);
    </script>
</body>

</html>
```