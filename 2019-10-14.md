## 相等符“==”的转换规则：

``` javascript
console.log('true' == true ); // false
console.log('true' == false ); // false
console.log('false' == true ); // false
console.log('false' == false ); // false
console.log('1' == true ); // true
console.log('0' == false ); // true
```

在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：
1. 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；
2. 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
3. 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较；


引用自[javascript 中：'true'==true ; 为什么返回false?](https://www.zhihu.com/question/61106507/answer/184310938)


## png, jpg, gif这几种格式的差别

在计算机中，图片分为**矢量图**和**位图**两种。

矢量图： 文件小，放大缩小图像不会失真； 但是表现的色彩不够丰富；
位图： 利于显示色彩层次丰富的写实图像；文件较大，放大后可能会出现图像失真的情况；

图片又分为**有损压缩**和**无损压缩**。

有损压缩：在人眼可接受的范围内，对图片进行压缩存储；在降低图像文件大小的情况下，会丢掉图像的原始信息，但人眼无法显著察觉；
无损压缩：完整地保留图像信息，最终的图像文件会较大；

### png
PNG又可以进一步分为png8/png24。理解这两种格式的区别，可以了解PNG格式的压缩原理。
通过索引图像上相同区域的颜色进行压缩和还原。

PNG8最多只能索引256种颜色，所以对于颜色较多的图像不能真实还原；PNG24则可 以保存1600多万种颜色，基本能够真实还原我们人类肉眼所可以分别的所有颜色；PNG格式最多可以保存48位颜色通道


### png与jpg的对比
| 格式	| 压缩模式 | 交错支持	| 透明支持|	动画支持 |
|----|----|-----|----|------|
| JPG	| 有损压缩 | 支持	   | 不支持	  | 不支持 |
| PNG	| 无损压缩 | 支持	   | 支持	  | 不支持 |


### gif
GIF格式：最大的特点是不仅可以是一张静止的图片,也可以是动画，并且支持透明背景图像，适用于多种操作系统，“体型”很小，网上很多小动画都是GIF格式。但是其色域不太广,只支持256种颜色。



### 结论
一般层次丰富颜色较多的图像采用JPG存储，而颜色简单对比强烈 的则需要采用PNG。但也会有一些特殊情况，例如有些图像尽管色彩层次丰富，但由于图片尺寸较小，上面包含的颜色数量有限时，也可以尝试用PNG进行存 储。而有些矢量工具绘制的图像由于采用较多的滤镜特效也会形成丰富的色彩层次，这个时候就需要采用JPG进行存储了。




## 为什么会有 CORB 的出现

### 旁路（Side Channel）攻击
首先需要了解的是旁路攻击这个术语，关于术语本身的解释，可以去维基百科搜索。简单讲的话，就是从软件系统的物理实现层获取信息进行攻击的手段，软件系统在正常运行时，产生了一些边缘特征，这些特征可以体现一些隐私信息。

这么说可能略显抽象，就拿后文视频链接中列举的例子说明一下，假设小 A 的账户密码是 gyease，小 B 想破解小 A 的密码，他可以这么做：

1. 首先他可以先输入 aaaaaa，之后记录一下从点击登录按钮到错误提示的间隔时间（虽然很短，假设有工具可以记录）
2. 之后再输入 baaaaa，同样记录时间
3. 重复以上过程直到 gaaaaa，会发现从点击登录按钮到错误提示的间隔时间稍微变长了一些
4. 之后小 B 即知道小 A 的密码第一位是 g，之后重复以上步骤即可破解小 A 的密码。

当然这里的例子很蠢，而且也过于理想化，但足够说明问题。反应快的读者可能马上就会知道为什么在观察 'gaaaaa' 的测量结果后小 B 就会知道小 A 首位密码，这是因为执行校验密码是否正确的代码是需要时间的，因此在理想条件下，首位错误和首位正确第二位错误的反馈结果必然是后者时间略长。

这就是一个比较典型的旁路攻击类型，专业的名称叫做计时攻击（timing attack），有兴趣的可以上网搜索了解详情。


### 预执行（speculation execution）
CPU为了提高性能，会在判断条件返回结果之前，预先执行里面的代码，如果条件成立，则直接返回之前预执行的结果。否则舍弃。

### 幽灵和熔断漏洞（Spectre & Meltdown）
利用CPU预执行的机制（只能算是一种机制，不能说是漏洞），程序可能取到非法值，例如下面这段代码

```
if(x < arr1.length){
    return arr2[arr1[x]]
}
```
上例中，x有可能大于arr.length, 此时不会返回arr2[arr1[x]]的值，但是在CPU预执行的前提下，我们可以提前获得arr2[arr[1]]的值，并将其放到缓存当中。之后遍历arr2,如果获取某个索引的值速度比较快（side-change attack），便可知道是从缓存中获取，这样我们就拿到了其它进程中的数据。



上面三个基本概念就构成了CORB的基础
[给程序员解释Spectre和Meltdown漏洞](https://zhuanlan.zhihu.com/p/32784852)
[30 分钟理解 CORB 是什么](https://www.cnblogs.com/oneasdf/p/9525490.html)