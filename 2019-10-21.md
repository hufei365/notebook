# 组件复用

## 组件复用的几种方式：
1. **mixin**
2. **HOC(High Order Component)**
3. **render props**

组件复用解决的问题是什么？答案很明显，DRY（Don't repeat yourself）。在一个体系内，对于同一件事情，只要有一个人去做就可以了。如果有多个人做同样的事情，不仅产出会有差别，效率也没有达到最好。举个简单的例子：
> 小明要蒸馒头和包子，但是二者都需要和面。那么在程序中，和面就是二者需要复用的逻辑。

```js
/* 蒸馒头*/
class Mantou{
    constructor(){
        console.log('huomian')
        console.log('mantou')
    }
}

/* 蒸包子*/
class Baozi{
    constructor(){
        console.log('huomian')
        console.log('baozi')
    }
}
```

*如果用上面集中复用的方式写这个业务呢？*

先看第一种： mixin。 
## Mixin
Mixin实现复用的本质是拷贝。以vue.js举例说明：

``` javascript
const mixin = {
    beforeCreate(){
        console.log('It is huomianing')
    }
}

// mantou
const Mantou = Vue.extend( {
    mixins: [mixin],
    mounted(){
        console.log('return mantou')
    }
})

// baozi
const Baozi = Vue.extend( {
    mixins: [mixin],
    mounted(){
        console.log('return baozi')
    }
})
// beforeCreated 是复用的地方，并且通过mixin的方式实现
```

vue.js使用mixin的方式其实质实在将mixin中的方法beforeCreated拷贝到了新的组件（Mantou和Baozi）上面。在vue.js源码中有一个名为`mergeOptions`深拷贝方法，里面有如下几行代码会将mixin中间的方法拷贝到新的组件当中。

```js
......
if (child.mixins) {
  for (var i = 0, l = child.mixins.length; i < l; i++) {
    parent = mergeOptions(parent, child.mixins[i], vm);
  }
}
......
```
既然是通过拷贝实现，那么mixin的东西（和面的逻辑）实际上已经侵入到原组件当中。原组件在使用时，看不出一个属性或这方法是来自于mixin还是自己本身所有。

## HOC(High Order Component)
如果我们用高阶组件的方式实现上述逻辑，那么代码应该是像下面这样：

```js
const Baozi = Vue.component('Baozi', {
    props: {
        name: String
    },
    template: "<div><h2 @click='log'> {{name}} </h2></div>",
    methods:{
        log(){
            console.log(Date.now(), this.name)
        }
    }
})

function HighOrderComp(comp) {
    return {
        data() {
            return {
                name: "a new Baozi"
            }
        },
        beforeCreate() {
            console.log("It is huomianing")
        },
        render(h) {
            console.log(this.name)
            return h(comp, { props: { name: this.name } })
        }
    }
}
const newBaozi = HighOrderComp(Baozi)
```




## Hooks
## class


# Function-based API


## 定位
实现逻辑组合和复用，举例说明：


``` javascript
function huomian(){
    console.log( "It is huomianing" )
}

class Baozi{
    constructor(){
        huomian();
        return {
            name: 'baozi'
        }
    }
}
class Mantou{
    constructor(){
        huomian()
        return {
            name: 'mantou'
        }
    }
}

// 复用的逻辑被写成了一个函数，供其他人使用
```
转换成vue源码，分别把包子和馒头看做一个组件。

``` javascript
const mixin = {
    beforeCreated(){
        console.log('It is huomianing')
    }
}
// baozi
export default {
    mixins: [mixin],
    mounted(){
        console.log('return baozi')
    }
}

// mantou
export default {
    mixins: [mixin],
    mounted(){
        console.log('return mantou')
    }
}

// beforeCreated 是复用的地方，并且通过mixin的方式实现
```

`mixin`是vue 2.x推荐的逻辑复用方案，而在React中，此场景下一般通过高阶组件（High-order Component）实现。

如果使用最新的Function-based Api写法呢？
``` javascript
function huomian(){
    console.log( "It is huomianing" )
}
// baozi
export default {
    setup(){
        onBeforeCreated(huomian) 
    },
    mounted(){
        console.log('return baozi')
    }
}

// mantou
export default {
    setup(){
        onBeforeCreated(huomian) 
    },
    mounted(){
        console.log('return mantou')
    }
}

// setup是实现逻辑复用的地方
```

这种写法初看和mixin区别不明显，但需要注意的一点是，在Function-based的写法中， setup中复用的逻辑是可以自由组合，如果蒸包子这件事的beforeCreated中再加上调馅这件事，可以再写一个调馅的方法`tiaoxian`，在setup中调用(这就叫逻辑组合)。这样就避免了mixin的复杂性（否则需要写两个mixin）


## 出现的原由
在此之前已经有现有的方案用于解决逻辑复用，主要有mixin, HOC, Slot。但或多或少存在如下一些问题：

1. 数据来源不清晰——mixin, HOC；？？ 数据来源怎么了，知道数据来源有什么用？对谁有好处？
2. 命名空间冲突——mixin, HOC; ？？ 为什么存在命名空间问题
3. 性能消耗——Slot；？？ 性能消耗体现哪方面
