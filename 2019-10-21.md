# 组件复用

为什么要有组件复用？直白地说即使DRY（Don't repeat yourself)。
> 避免重写组件本身，并允许有状态逻辑的不同部分能无缝地进行协同工作。


## 组件复用的几种模式：
1. **mixin**
2. **HOC(High Order Component)**
3. **render props**
4. **hooks**

组件复用解决的问题是什么？答案很明显，DRY（Don't repeat yourself）。在一个体系内，对于同一件事情，只要有一个人去做就可以了。如果有多个人做同样的事情，不仅产出会有差别，效率也没有达到最好。举个简单的例子：
> 小明要蒸馒头和包子，但是二者都需要和面。那么在程序中，和面就是二者需要复用的逻辑。

```js
/* 蒸馒头*/
class Mantou{
    constructor(){
        console.log('huomian')
        console.log('mantou')
    }
}

/* 蒸包子*/
class Baozi{
    constructor(){
        console.log('huomian')
        console.log('baozi')
    }
}
```

*如果用上面几中复用的模式写这个业务呢？*

先看第一种： mixin。 
## Mixin
Mixin实现复用的本质是拷贝。以vue.js举例说明：

``` javascript
const mixin = {
    beforeCreate(){
        console.log('It is huomianing')
    }
}

// mantou
const Mantou = Vue.extend( {
    mixins: [mixin],
    mounted(){
        console.log('return mantou')
    }
})

// baozi
const Baozi = Vue.extend( {
    mixins: [mixin],
    mounted(){
        console.log('return baozi')
    }
})
// beforeCreated 是复用的地方，并且通过mixin的方式实现
```

vue.js使用mixin的方式其实质实在将mixin中的方法beforeCreated拷贝到了新的组件（Mantou和Baozi）上面。在vue.js源码中有一个名为`mergeOptions`深拷贝方法，里面有如下几行代码会将mixin中间的方法拷贝到新的组件当中。

```js
......
if (child.mixins) {
  for (var i = 0, l = child.mixins.length; i < l; i++) {
    parent = mergeOptions(parent, child.mixins[i], vm);
  }
}
......
```
既然是通过拷贝实现，那么mixin的东西（和面的逻辑）实际上已经侵入到原组件当中。原组件在使用时，看不出一个属性或这方法是来自于mixin还是自己本身所有。

mixins存在的两个问题
1. 不能相互消费
2. 状态来源不清晰
3. 存在命名空间冲突的风险
4. 多个mixin同时存在时，有可能导致风险和复杂度暴涨

## HOC(High Order Component)
如果我们用高阶组件的方式实现上述逻辑，那么代码应该是像下面这样：

```js
const Baozi = Vue.component('Baozi', {
    props: {
        name: String
    },
    template: "<div><h2 @click='log'> {{name}} </h2></div>",
    methods:{
        log(){
            console.log(Date.now(), this.name)
        }
    }
})

function HighOrderComp(comp) {
    return {
        data() {
            return {
                name: "a new Baozi"
            }
        },
        beforeCreate() {
            console.log("It is huomianing")
        },
        render(h) {
            console.log(this.name)
            return h(comp, { props: { name: this.name } })
        }
    }
}
const newBaozi = HighOrderComp(Baozi)
```
## Hooks
hooks本身可以看作组织逻辑的一种通用方式，与react无关。前面讲的组件复用的两种方式，mixin的实质是复制。将需要复用的部分写好一份，调用者需要的时候复制一份到自己身上。高阶组件的本质类似于魔改，在已有组件的基础上，封装一层皮，产生一个新的组件供别人调用。 而hooks复用的方式是局部业务的复用。在组件的生命周期内，预先留好挂接点，挂接外部逻辑。通过挂接的逻辑影响组件的状态和表现。


在React中，这种复用模式叫Hooks，在vue3.0中叫做 Function-based API。

```js
const MAX = 3;
function Huomian(props) {
	let [time, updateTime] = useState(0);
	let max = props.max;
	useEffect(() => {
		let id = setInterval(() => {
			time++;
			if (time <= max) updateTime(time++);
			else {
				props.onDone()
			}
		}, 800);
		return () => clearInterval(id);
	})
	return <p>{time} seconds gone~~ ( after {max} seconds)</p>
}
function Mantou() {
	let [done, updateDone] = useState(false)
	return <div> {done ? <p>  蒸馒头</p> : <Huomian max={MAX} onDone={() => { updateDone(!done) }}></Huomian>}</div>
}
function Baozi(){
	let [done, updateDone] = useState(false)
	return <div>
		{done ? <p>蒸包子</p> : <Huomian max={MAX+3} onDone={ ()=>{updateDone(!done)}}></Huomian>}
	</div>
}
```

在Hooks出现之前，存在的组件复用模式都不完美，或多或少有一些问题。

1. 数据来源不清晰——mixin, HOC；
2. 命名空间冲突——mixin, HOC; 
3. 性能消耗——Slot；性能消耗体现哪方面

## hooks存在的一些问题？？
