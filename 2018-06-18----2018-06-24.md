### 函数劫持和钩子函数
JavaScript中， 函数劫持的本质就是重写该函数。但是在重写的时候，我们应该注意的是要把原来的方法进行保存，这样就不会担心原来的方法被覆盖掉而不能调用。
```javascript
// 劫持window.alert函数

function myalert(){ console.log('cosole.log my alert func' );}

var _alert = alert;

alert = function(){
    myalert.apply(this, arguments);
    _alert.apply(this, arguments);
}

alert('Hello');
```

**钩子函数**
在某些通信过程中，发信者故意留下一个钩子，用于收信者执行收到信息后处理。收信者在预先初始化收信后的处理操作时，执行的操作就是重写发信者留下的钩子。这个过程一般是通过函数劫持实现的。
```javascript
var source = (function () {
    return {
        click: function () {
            console.log("I am source func");
        },
        fire: function (event) {
            console.log(event + ' fired!!');
            console.log('start call eventfunc: ' + event);
            this[event]();
        },

        on: function (event, fn) {
            var _eventFn = this[event];

            this[event] = function () {
                fn.apply(this, arguments);
                _eventFn.apply(this, arguments);
            }

        }
    }
})();

source.on('click', function () {
    console.log("this is  message~~~");
})

source.fire('click'); // 输出结果如下：
// click fired!!
// start call eventfunc: click
// this is  message~~~
// I am source func
```

**monkey patch**


### 浏览器内核
浏览器内核一般由 **渲染引擎** 和 **JS引擎** 两部分构成。但后来JS引擎越来越倾向于独立，所以到现在，浏览器内核一般倾向于指渲染引擎。

渲染引擎（Rendering Engineer）

关于浏览器内核，网上资料说的最多的就是内核的分类。
市场上现有的内核由 Trident、Gecko、WebKit、Blink这四种。
微软新出的浏览器Edge采用了新的渲染引擎和在IE9+上使用的JSi 引擎，Chakra。

不用说，大家都知道，Trident是传统IE采用的内核；
Gecko是FireFox团队研发的新内核，一般用在FireFox浏览器上。
WebKit是Apple公司基于KHTML/KJS研发的内核，最开始用在自家的Safari浏览器上，后来开源；
Blink是Google基于WebKit研发的内核，用在了自家最新的Chrome浏览器上。

**渲染引擎的大致渲染流程**：
1. 解析HTML数据，生成DOM树；
2. 遇到CSS代码，解析生成CSSOM；
3. 将DOM和CSSOM合并，生成渲染树；
4. 布局解析器跟据渲染树计算元素的大小和相对位置；
5. JS 引擎解析JS代码，并修改DOM或CSSOM；
6. 在屏幕上绘制最终呈现效果；

要注意的是，这个流程并不是只走一次就完事。在第5步的时候，也可能会出发前面的1、2步。


**目前市面上的JS引擎**：
- JSCore webkit中使用JS引擎
- V8 Google为替换JSCore研发的引擎
- Chakra 微软最新的JS引擎
- KJS KDE开源的JS引擎，JSCore正式基于此研发；
- SpiderMonkey FireFox等少数浏览器使用的JS引擎

[浏览器的渲染：过程与原理](http://web.jobbole.com/92765/?utm_source=blog.jobbole.com&utm_medium=relatedPosts)

[浏览器工作原理 （一） ： 浏览器渲染原理 & 浏览器内核](https://segmentfault.com/a/1190000009975744)

还有一篇写的比较深入的一篇文章，对JS引擎中的Shapes 和 Inline Caches做了阐述。

[JavaScript 引擎基础：Shapes 和 Inline Caches](https://zhuanlan.zhihu.com/p/38202123)

浏览器除了完成DOM解析渲染和JS代码的执行，还由网络请求、HTTP协议实现、用户事件、存储、历史记录等其它feature。




### window.onload 与 document的ready状态有什么区别

**document的ready** 状态是在dom文档加载完以后触发，此时页面的上的一些图片之类的数据可能还没加载完成，但是DOM结构已经加载完成。

当HTML文档下载并解析完成以后，就会在document对象上触发DOMContentLoaded事件。这时，仅仅完成了HTML文档的解析（整张页面的DOM生成），所有外部资源（样式表、脚本、iframe等等）可能还没有下载结束。也就是说，这个事件比load事件，发生时间早得多。

IE8不支持DOMContentLoaded事件，但是支持这个事件。因此，可以使用readystatechange事件，在低版本的IE中代替DOMContentLoaded事件。


**window.onload**是指页面上的所有资源都加载完成，包括所有图片等资源。

所以可以看出，window.onload是在 document.ready之后触发。


#### beforeunload
 beforeunload 事件是在离开当前页之前触发
``` javascript
window.addEventListener('beforeunload', beforeunload)

function beforeunload(e){
    var confirmMsg = 'Are you going to leave?';
   e.preventDefault(); //  取消事件的默认行为 方式一
    (e || window.event).returnValue = confirmMsg; // 取消事件的默认行为 方式二 （PS: Chrome浏览器需设置 e.returnValue 属性值才可以生效）
    return confirmMsg;
}

// window.removeEventListener('beforeunload',beforeunload);
```
方式一和方式二对FireFox 和 IE11(其它版本未测试) 都有效

Chrome 只会响应方式二的设置

除了IE11, 会显示`confirmMsg`的内容，Chrome及FireFox都不会显示`confirmMsg`的内容。


**那么就留下一个问题，`event.returnValue`属性的具体含义？**
《JavaScript高级程序设计》给出的解释：IE(确切的说，应该是低版本的IE)事件对象的属性，默认为true；设置为false后，可以取消事件的默认行为。（这也是我之前的认知）

但是在`beforeunload`事件的实验中，发现它的属性值对Chrome是有影响的。

[[js点滴]JavaScript之文档事件08](https://blog.csdn.net/BaiHuaXiu123/article/details/53148896)

#### 事件节流

 **方式一 clearTimeout**
 ```javascript
var throttle = (function () {
    var timer = null;
    var prev = null;
    var throttle = function () {
        clearTimeout(timer);
        var fn = Array.prototype.shift.call(arguments);
        var params = arguments;
        var that = this;
        prev = prev || +new Date();
        var cur = +new Date();
        if (cur - prev > 1000) {
            fn.apply(that, params);
            prev = cur;
        } else {
            timer = setTimeout(function () {
                fn.apply(that, params);
                prev = null;
            }, 500);
        }
    }
    return throttle;
})();
window.addEventListener('scroll', function(e){
    throttle(function(e){
        console.log(e);
    }, e);
});
 ```

**方式二 setTimeout**
 同样是使用了setTimeout，但是不同于方式一的是，方式二通过设置一个开关`timer`来判断是否需要创建新的setTimeout
 ``` javascript
var throttle = (function () {
    var timer = null;
    return function () {
        if (!timer) {
            var fn = Array.prototype.shift.call(arguments);
            var params = arguments;
            var that = this;
            timer = setTimeout(function () {
                fn.apply(that, params);
                timer = 0;
            }, 500
            )
        }
    }
})();
window.addEventListener('scroll', function(e){
    throttle(function(e){
        console.log(e);
    }, e);
});
 ```

 **方式三 setInterval**
很像方式二，也有一个开关设置。但不同于方式二的是，开关设置是通过setInterval定时器来设置的。在窗口时间内，会响应事件。
``` javascript
var throttle = (function () {
    var timer = null;
    window.setInterval(function () {
        timer = true;
    }, 500);
    return function () {
        if (timer) {
            var fn = Array.prototype.shift.call(arguments);
            var params = arguments;
            var that = this;
            fn.apply(that, params);
            timer = false;
        }
    }
})();
window.addEventListener('scroll', function(e){
    throttle(function(e){
        console.log(e);
    }, e);
});
```

#### 事件防抖
下面的防抖方法（debounce）是 lodash 中的实现。
`immediate`如果设置为true，则在事件触发时就立即执行一次回调函数，之后不再执行；反之，则在事件触发完成后，只触发一次。无论哪种方式，事件都只会触发一次。
``` javascript
function debounce(func, wait, immediate) {
    var args,
        result,
        thisArg,
        timeoutId;
    function delayed() {
        timeoutId = null;
        if (!immediate) {
            result = func.apply(thisArg, args);
        }
    }
    return function () {
        var isImmediate = immediate && !timeoutId;
        args = arguments;
        thisArg = this;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(delayed, wait);
        if (isImmediate) {
            result = func.apply(thisArg, args);
        }
        return result;
    };
}
var func = debounce(function () {
        console.log('12 3 34 4');
    }, 500, true);
window.addEventListener('resize', func);
```