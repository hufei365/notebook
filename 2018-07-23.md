## node是什么
> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 


**运行环境**， 不是一门语言，不是一个框架。只是能够作为JavaScript代码运行的一个环境。 

而这个运行环境主要是由V8提供的。

### V8做了什么？
创建了一个callstack。

``` javascript
function main(){
    func1();
}
function func1(){
    func2();
}
function func2(){
    console.log(1);
}
main();
```

![V8 Engine](http://p9jftl6n6.bkt.clouddn.com/V8%20engine.png)


### 除去V8，Node中还有哪些东西?

除去V8，Node中另外一个比较重要的组成就是 **libuv**。

What? `libuv`是什么鬼？

先说说，关于Node的另外一句话：
>  Node is designed to build scalable network applications.

这句话的底气在哪儿，就是Node本身采用的 **事件驱动，非阻塞I/O模型**。

在 **并发模型构建网络的应用**中，每个连接都会生成一个新线程，每个新线程可能需要 2MB 的配套内存。在一个拥有 8 GB RAM 的系统上，理论上最大的并发连接数量是 4,000 个用户。随着您的客户群的增长，如果希望您的 Web 应用程序支持更多用户，那么，您必须添加更多服务器。所以在传统的后台开发中，整个 Web 应用程序架构（包括流量、处理器速度和内存速度）中的瓶颈是：服务器能够处理的并发连接的最大数量。这个不同的架构承载的并发数量是不一致的。 

![traditional-web-server-model](http://p9jftl6n6.bkt.clouddn.com/traditional-web-server-model.png)

Node的解决这个问题思路：
1. 在网络应用中，比较慢的环节主要在 磁盘读取或 网络请求阶段，这时候CPU处于闲置状态。
2. 如果在等待I/O操作时，能够释放处于闲置状态的CPU，则可以很大程度上利用资源；
3. 那么接下来的问题就在于，如何在I/O 操作完成后，继续执行后续的操作；
4. 解决方案：采用回调，事件驱动。这本身也是JavaScript的特点————**Event Loop**。

![nodejs-process-model](http://p9jftl6n6.bkt.clouddn.com/nodejs-process-model.png)

*具体是怎么做的？*

在程序运行时，把I/O操作交给其他线程去处理，只留一个线程进行业务处理（执行JS代码）。等到I/O操作完成后，再将回调方法扔给业务处理线程。

``` javascript
const fs = require('fs');

const readFile = (file) => {
    fs.readFile(file, (err, data) => {
        if(!err) console.log(data);
    });
}

console.log('program start ......');
readFile('file.json');
console.log('readFile has put the I/O ');
console.log('program end!!!!!');
```
![V8 async](http://p9jftl6n6.bkt.clouddn.com/V8%20async.png)

负责异步程序调度的工作就是`libuv`做的事情。

> Libuv is a multi-platform support library with a focus on asynchronous I/O.

在上述程序中，当遇到文件读取操作时，V8会把js接口转成C++接口调用libuv暴露出的接口，此时libuv接管文件读取任务。当文件读取完成后，libuv就会通知V8，V8就会把这个事件的回调函数扔到JS的事件队列里。当JS下一次检查事件队列时，就会执行该回调函数。


再捋一捋Node, V8 和libuv的关系。
1) nodejs主要由V8 javascript引擎和libuv组成;
2) v8引擎主要负责解释执行js代码，碰到需要异步的操作会调用libuv实现的api;
3) libuv本身是独立的c语言库，可以直接使用c/c++来调用;


在我们的传统认知中，JS是没有能力进行文件读取操作的。而在Node中可以，肯定是Node干的好事！再来说说Node中其它一些组成部分

### Node扩展了JS的能力：builtin modules

builtin modules是由C++代码写成各类模块，包含了crypto，zlib, file stream etc 基础功能。（v8提供了函数接口，libuv提供异步IO模型库，以及一些nodejs函数，为builtin modules提供服务）。

###  native modules
除了builtin modules， 还有一个native modules。这是一个用js的内建模块，提供给程序开发者使用。

- global
- fs
- http


至此，Node的基本构成和运行原理已经讲完了。

TODO:上图：

![Node 构成](http://p9jftl6n6.bkt.clouddn.com/Node%20event%20loop.png)


补充一句：Node.js的单线程并不是真正的单线程，只是开启了单个线程进行业务处理（cpu的运算），同时开启了其他线程专门处理I/O。当一个指令到达主线程，主线程发现有I/O之后，直接把这个事件传给I/O线程，不会等待I/O结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是“单线程”、“异步I/O”。 

由于node中主任务的执行是以单线程的方式进行，如果程序出错导致崩溃，就会终止整个流程。为此，市场上有些Node进程管理工具，它们会维护Node程序的状态，当程序挂掉时，会自动重启。比如我们使用的`pm2`

**IO.js**

``` javascript
var fork = require('child_process').fork;
var fs = require('fs');

console.log('start......');

// blocking
// console.log(fs.readFileSync('test.json', 'utf-8'));

// non blocking
var childProcess = fork('another-thread.js');
childProcess.on('message', function(data){
    console.log(data);
})

console.log('end !!!');
```

**another-child.js**

``` javascript
var fs = require('fs');
process.send( fs.readFileSync('test.json', 'utf-8'));
```





## NPM
对于node没有的一些模块（native modules），可以引入外部模块。这些外部模块通常是其它开发者贡献的。

那么问题来了，对于数量众多的模块中，如何快速找到自己想要的并能够快速的引进到自己的项目当中。

这就是npm帮我们做的工作。

> Use npm to install, share, and distribute code; manage dependencies in your projects; and share & receive feedback with others.

[npm官网](https://www.npmjs.com/)

- 模块安装：
- 模块共享
- 发布代码
- 管理依赖
- 共享和反馈

### NPM的基本模式

NPM是JavaScript包的管理器。

![NPM basic](http://p9jftl6n6.bkt.clouddn.com/NPM%20basic.png)


### 广义的npm的构成

npm consists of three distinct components:

- the website： NPM官方站点
- the Command Line Interface (CLI) ： NPM命令行工具
- the registry： JS模块的数据库

Use the `website` to discover packages, set up profiles, and manage other aspects of your npm experience. For example, you can set up Orgs (organizations) to manage access to public or private packages.

The `CLI` runs from a terminal. This is how most developers interact with npm.

The `registry` is a large public database of JavaScript software and the meta-information surrounding it.


### npm中的使用

#### 查找一个包
去npm官网，按关键词查找。

#### 安装模块
`npm instsall [module name]`

包安装完成后，会在当前目录生成一个node_modules目录。这是一个存放外部js的地方，通过npm安装的包都放在这个目录下。

#### package.json

TODO:
`package.json`是一个nodejs和npm都会自动读取的配置文件，它里面是个标准的JSON格式字符串。





## Node的全局变量和内置模块
同浏览器中的`window`一样，在Node中的全局变量都挂在`global`下。

### process
`process` 对象是一个全局变量，它提供当前 Node.js 进程的有关信息，以及控制当前 Node.js 进程。 

- process.argv: 包含命令行参数的数组。第一个元素会是'node'，第二个元素将是.js文件的名称，接下来的参数依次是命令行参数
- process.execArgv: 启动进程所需的 node 命令行参数。这些参数不会在 process.argv 里出现，并且不包含 node 执行文件的名字，或者任何在名字之后的参数。这些用来生成子进程，使之拥有和父进程有相同的参数
- process.env: 获取当前系统环境信息的对象，常规可以用来进一步获取环境变量、用户名等系统信息


**process.js**

``` javascript
console.log(process.argv);
console.log(process.execArgv);
```

``` shell
node process.js
# [ '/usr/local/bin/node', '/root/node-demo/process.js' ]
# []

node process.js abc 234 cvb=cvb
# [ '/usr/local/bin/node',
#   '/root/node-demo/process.js',
#   'abc',
#   '234',
#   'cvb=cvb' ]
# []


node --harmony  --use-openssl-ca  process.js abc 234 cvb=cvb
# [ '/usr/local/bin/node',
#   '/root/node-demo/process.js',
#   'abc',
#   '234',
#   'cvb=cvb' ]
# [ '--harmony', '--use-openssl-ca' ]

```



### fs


## deno


[Nodejs的运行原理-科普篇](https://www.cnblogs.com/peiyu1988/p/8032982.html)

[Awesome Micro npm Packages](https://github.com/parro-it/awesome-micro-npm-packages)

[libuv 官网](http://libuv.org/)